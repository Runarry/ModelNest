# ModelNest 服务层引入执行方案

## 1. 引言

**目标**: 本文档旨在提供一份详细的、可操作的执行计划，指导如何将 ModelNest 主进程的现有代码重构，引入服务层架构。

**背景**: 根据项目架构分析报告 (`doc/project-review-report.md`) 和服务层设计方案 (`doc/设计文档.md` 中相关部分)，引入服务层旨在解决当前代码中业务逻辑耦合、职责不清、可维护性差等问题。

**核心原则**:
*   **分离职责**: 将业务逻辑（配置、数据源、模型、图片处理、更新）从 `main.js` 和 `src/ipc/modelLibraryIPC.js` 中剥离到独立的服务模块。
*   **提升内聚**: 将相关功能集中到对应的服务中。
*   **降低耦合**: 使 IPC 层成为轻量级路由，简化 `main.js`。
*   **明确接口**: 为渲染进程和内部模块提供清晰、稳定的服务接口。

**最终目标**: 实现一个更清晰、模块化、可维护和可测试的主进程架构。

## 2. 准备工作

1.  **创建目录**: 在 `src/` 目录下创建 `services/` 目录。

    ```
    src/
    └── services/
    ```
2.  **创建服务文件**: 在 `src/services/` 目录下创建以下初始空文件：
    *   `configService.js`
    *   `dataSourceService.js`
    *   `modelService.js`
    *   `imageService.js`
    *   `updateService.js`  <-- 新增
    *   `index.js` (用于服务注册和初始化)

## 3. 服务实现与迁移：ConfigService
<!-- Section 3: ConfigService - Implementation Completed -->

**目标**: 将所有应用配置相关的逻辑（加载、保存、访问）集中到 `ConfigService`，并移除旧的 `configManager.js`。

**步骤**:

1.  **创建 `src/services/configService.js`**:
    *   引入所需模块: `fs`, `path`, `log`, `app` (来自 `electron`)。
    *   定义 `ConfigService` 类或模块。

2.  **迁移配置加载逻辑**:
    *   将 `main.js` 中的 `loadConfig` 函数的**核心逻辑**移动到 `ConfigService` 的一个私有方法（例如 `_loadConfigFromFile`）或初始化方法中。
    *   **关键逻辑包括**:
        *   确定配置文件路径 (`path.join(app.getPath('userData'), 'config.json')`)。
        *   使用 `fs.promises` 读取文件内容。
        *   `JSON.parse` 解析配置。
        *   处理本地数据源路径转换（相对路径转绝对路径）。
        *   错误处理（文件不存在、解析失败）和设置默认配置。
    *   `ConfigService` 内部维护一个变量（如 `this.config`）来存储加载的配置。

3.  **迁移配置保存逻辑**:
    *   将 `main.js` 中 `ipcMain.handle('save-config', ...)` 的**核心文件写入和状态更新逻辑**移动到 `ConfigService` 的 `saveConfig(newConfig)` 方法中。
    *   **关键逻辑包括**:
        *   确定配置文件路径。
        *   `JSON.stringify` 序列化配置。
        *   使用 `fs.promises.writeFile` 写入文件。
        *   更新 `ConfigService` 内部存储的配置 (`this.config = newConfig`)。
        *   **注意**: 触发配置更新事件的逻辑 (`BrowserWindow.getAllWindows().forEach(...)`) **不应**放在 `ConfigService` 中，这属于主进程协调逻辑，应在调用 `saveConfig` 成功后在 IPC handler 中执行。同样，更新 `imageCache` 配置的逻辑 (`imageCache.setConfig`) 也应在外部完成。
        *   错误处理。

4.  **实现服务接口**:
    *   `getConfig(): Promise<AppConfig>`: 返回内部存储的完整配置对象 (`this.config`)。可以考虑返回深拷贝以防止外部修改。
    *   `getSetting(key: string): Promise<any>`: 从 `this.config` 中获取指定 `key` 的值。
    *   `saveConfig(config: AppConfig): Promise<void>`: 调用内部的保存逻辑。

5.  **初始化**:
    *   `ConfigService` 需要一个初始化方法（例如 `async initialize()`），该方法调用内部的 `_loadConfigFromFile` 来加载初始配置。这个初始化方法将在服务注册阶段被调用。

6.  **删除旧文件**:
    *   确认 `ConfigService` 功能完整并被正确初始化后，删除 `src/configManager.js` 文件。
    *   更新所有 `require('../configManager.js')` 的地方，改为从初始化后的服务实例获取配置。

## 4. 服务实现与迁移：DataSourceService
<!-- Section 4: DataSourceService - Implementation Completed -->

**目标**: 管理数据源配置信息，为其他服务提供统一的数据源访问接口。

**步骤**:

1.  **创建 `src/services/dataSourceService.js`**:
    *   引入所需模块: `log`.
    *   定义 `DataSourceService` 类或模块。
    *   **依赖注入**: 需要接收 `ConfigService` 实例作为依赖。

2.  **实现服务接口**:
    *   `getSourceConfig(sourceId: string): Promise<SourceConfig | null>`:
        *   从注入的 `ConfigService` 获取完整配置 (`await this.configService.getConfig()`)。
        *   在 `config.modelSources` 数组中查找并返回与 `sourceId` 匹配的配置对象。
        *   如果未找到，返回 `null` 并记录警告。
        *   **来源**: 这部分逻辑目前分散在 `src/ipc/modelLibraryIPC.js` 的多个 handler 中。需要将其统一到此方法。
    *   `getAllSourceConfigs(): Promise<SourceConfig[]>`:
        *   从 `ConfigService` 获取配置。
        *   返回 `config.modelSources` 数组（或空数组）。
    *   `getSupportedExtensions(): Promise<string[]>`:
        *   从 `ConfigService` 获取配置。
        *   返回 `config.supportedExtensions` 数组（或空数组）。
        *   **来源**: `src/ipc/modelLibraryIPC.js` line 80。

3.  **初始化**:
    *   `DataSourceService` 实例将在服务注册阶段创建，并注入 `ConfigService` 实例。

## 5. 服务实现与迁移：ModelService
<!-- Section 5: ModelService - Implementation Completed -->

**目标**: 负责模型的 CRUD 逻辑，包括列表获取、详情读取、数据解析与准备、保存操作。

**步骤**:

1.  **创建 `src/services/modelService.js`**:
    *   引入所需模块: `log`, `fs`, `path`, `dataSourceInterface`, `modelParser`。
    *   定义 `ModelService` 类或模块。
    *   **依赖注入**: 需要接收 `DataSourceService` 实例作为依赖。

2.  **迁移 `saveModel` 逻辑**:
    *   将 `src/ipc/modelLibraryIPC.js` 中 `handle('saveModel', ...)` 的**核心业务逻辑**移动到 `ModelService` 的 `async saveModel(modelData: object): Promise<{success: boolean}>` 方法中。
    *   **关键逻辑包括**:
        *   参数校验 (`modelData.jsonPath` 必须存在)。
        *   使用 `fs.promises.readFile` 读取现有 JSON 文件内容。
        *   调用 `modelParser.prepareModelDataForSaving` 合并和准备最终数据。
        *   `JSON.stringify` 序列化数据。
        *   **调用 `DataSourceService`**: 使用 `await this.dataSourceService.getSourceConfig(modelData.sourceId)` 获取 `sourceConfig`。
        *   **调用 `dataSourceInterface`**: 使用 `await dataSourceInterface.writeModelJson(sourceConfig, modelData, dataToWrite)` 写入文件。
        *   错误处理和日志记录。
    *   **返回值**: `{ success: true }` 或抛出错误。

3.  **迁移 `listModels` 逻辑**:
    *   将 `src/ipc/modelLibraryIPC.js` 中 `handle('listModels', ...)` 的**核心业务逻辑**移动到 `ModelService` 的 `async listModels(sourceId: string, directory: string): Promise<ModelInfo[]>` 方法中。
    *   **关键逻辑包括**:
        *   **调用 `DataSourceService`**:
            *   `await this.dataSourceService.getSourceConfig(sourceId)` 获取 `sourceConfig`。
            *   `await this.dataSourceService.getSupportedExtensions()` 获取 `supportedExts`。
        *   **调用 `dataSourceInterface`**: 使用 `await dataSourceInterface.listModels(sourceConfig, directory, supportedExts)` 获取模型列表。
        *   错误处理和日志记录。
    *   **返回值**: 模型信息数组或抛出错误。

4.  **迁移 `listSubdirectories` 逻辑**:
    *   将 `src/ipc/modelLibraryIPC.js` 中 `handle('listSubdirectories', ...)` 的**核心业务逻辑**移动到 `ModelService` 的 `async listSubdirectories(sourceId: string): Promise<string[]>` 方法中。
    *   **关键逻辑包括**:
        *   **调用 `DataSourceService`**: `await this.dataSourceService.getSourceConfig(sourceId)` 获取 `sourceConfig`。
        *   **调用 `dataSourceInterface`**: 使用 `await dataSourceInterface.listSubdirectories(sourceConfig)` 获取子目录列表。
        *   错误处理和日志记录。
    *   **返回值**: 子目录字符串数组或抛出错误。

5.  **迁移 `getModelDetail` 逻辑**:
    *   将 `src/ipc/modelLibraryIPC.js` 中 `handle('getModelDetail', ...)` 的**核心业务逻辑**移动到 `ModelService` 的 `async getModelDetail(sourceId: string, jsonPath: string): Promise<ModelDetail>` 方法中。
    *   **关键逻辑包括**:
        *   **调用 `DataSourceService`**: `await this.dataSourceService.getSourceConfig(sourceId)` 获取 `sourceConfig`。
        *   **调用 `dataSourceInterface`**: 使用 `await dataSourceInterface.readModelDetail(sourceConfig, jsonPath)` 读取模型详情。
        *   错误处理和日志记录。
    *   **返回值**: 模型详情对象或抛出错误。

6.  **初始化**:
    *   `ModelService` 实例将在服务注册阶段创建，并注入 `DataSourceService` 实例。

## 6. 服务实现与迁移：ImageService
<!-- Section 6: ImageService - Implementation Completed -->

**目标**: 负责模型图片的获取、缓存查找、压缩处理、缓存写入及临时文件管理。

**步骤**:

1.  **创建 `src/services/imageService.js`**:
    *   引入所需模块: `log`, `fs`, `path`, `crypto`, `dataSourceInterface`, `imageCache`。
    *   定义 `ImageService` 类或模块。
    *   **依赖注入**: 需要接收 `DataSourceService` 实例作为依赖。

2.  **迁移 `getModelImage` 逻辑**:
    *   将 `src/ipc/modelLibraryIPC.js` 中 `handle('getModelImage', ...)` 的**核心业务逻辑**移动到 `ImageService` 的 `async getImage(sourceId: string, imagePath: string): Promise<{path: string, data: Buffer, mimeType: string} | null>` 方法中。
    *   **关键逻辑包括**:
        *   **调用 `DataSourceService`**: `await this.dataSourceService.getSourceConfig(sourceId)` 获取 `sourceConfig`。
        *   **缓存 Key 生成**: 计算缓存 key (`hashKey`)。
        *   **缓存路径计算**: 计算 `cachePath`。
        *   **检查缓存**: 使用 `fs.existsSync` 和 `fs.promises.readFile` 检查并读取缓存。如果命中，直接返回缓存数据。
        *   **调用 `dataSourceInterface`**: 如果缓存未命中，调用 `await dataSourceInterface.getImageData(sourceConfig, imagePath)` 获取原始图片数据或路径。
        *   **处理 WebDAV 临时文件**: 如果是 WebDAV 源且返回了数据，将其写入临时文件 (`tempFilePath`)。
        *   **调用 `imageCache`**: 调用 `await imageCache.getCompressedImage(sourceImagePathForCache, hashKey)` 进行压缩和缓存写入。`sourceImagePathForCache` 根据源类型可能是原始本地路径或 WebDAV 临时文件路径。
        *   **读取最终缓存文件**: 使用 `fs.promises.readFile` 读取压缩后的缓存文件。
        *   **清理临时文件**: 如果创建了 WebDAV 临时文件，并且它与最终缓存文件不同，则删除临时文件。
        *   **构造返回结果**: 包含最终缓存文件路径、Buffer 数据和 mimeType。
        *   全面的错误处理和日志记录。
    *   **返回值**: 包含图片路径、数据和 mimeType 的对象，或在失败时返回 `null`。

3.  **初始化**:
    *   `ImageService` 实例将在服务注册阶段创建，并注入 `DataSourceService` 实例。

## 7. 服务实现与迁移：UpdateService
<!-- Section 7: UpdateService - Implementation Completed -->

**目标**: 封装 `electron-updater` 的交互逻辑，提供统一的应用更新服务接口。

**步骤**:

1.  **创建 `src/services/updateService.js`**:
    *   引入所需模块: `log`, `autoUpdater` (来自 `electron-updater`)。
    *   定义 `UpdateService` 类或模块。
    *   **依赖注入**: 可能需要 `BrowserWindow` 实例或 `webContents` 来发送消息，或者通过事件总线解耦。

2.  **实现服务职责**:
    *   **封装 `autoUpdater` 事件监听**:
        *   在服务内部监听 `autoUpdater` 的关键事件，如 `checking-for-update`, `update-available`, `update-not-available`, `download-progress`, `update-downloaded`, `error`。
        *   在事件回调中，记录日志，并**通过 `webContents.send('updater.onUpdateStatus', ...)` 向渲染进程发送结构化的状态更新**。例如：
          ```javascript
          // 伪代码
          autoUpdater.on('update-available', (info) => {
            log.info('[UpdateService] 发现可用更新:', info);
            this.sendStatusToRenderer({ status: 'available', info });
          });
          autoUpdater.on('update-downloaded', (info) => {
            log.info('[UpdateService] 更新已下载:', info);
            this.sendStatusToRenderer({ status: 'downloaded', info });
          });
          // ... 其他事件
          ```
    *   **实现服务接口**:
        *   `checkForUpdates(): void`: 调用 `autoUpdater.checkForUpdates()`。
        *   `quitAndInstall(): void`: 调用 `autoUpdater.quitAndInstall()`。
    *   **初始化**:
<!-- Section 8: Service Initialization & DI - Implementation Completed -->
        *   在服务初始化时设置 `autoUpdater.autoDownload = false` （或根据需要配置）。
        *   开始监听 `autoUpdater` 事件。
        *   提供一个方法 `setWebContents(webContents)` 或类似机制，让主进程在创建窗口后将 `webContents` 传递给服务，以便发送状态更新。

## 8. 服务初始化与依赖注入

**目标**: 在应用程序启动时，实例化所有服务并处理它们之间的依赖关系。

**方案**: 使用 `src/services/index.js` 作为服务注册和初始化中心，采用手动依赖注入。

**步骤**:

1.  **编辑 `src/services/index.js`**:
    *   引入所有服务类/模块 (`ConfigService`, `DataSourceService`, `ModelService`, `ImageService`, `UpdateService`)。
    *   定义一个 `async initializeServices()` 函数。
    *   **实例化顺序**:
        *   创建 `ConfigService` 实例: `const configService = new ConfigService();`
        *   调用其初始化方法: `await configService.initialize();` (等待配置加载完成)
        *   创建 `DataSourceService` 实例，注入 `configService`: `const dataSourceService = new DataSourceService(configService);`
        *   创建 `ModelService` 实例，注入 `dataSourceService`: `const modelService = new ModelService(dataSourceService);`
        *   创建 `ImageService` 实例，注入 `dataSourceService`: `const imageService = new ImageService(dataSourceService);`
        *   创建 `UpdateService` 实例: `const updateService = new UpdateService();` (可能需要后续注入 webContents)
        *   调用其初始化方法: `updateService.initialize();`
    *   返回一个包含所有服务实例的对象:
        ```javascript
        return {
          configService,
          dataSourceService,
          modelService,
          imageService,
          updateService, // <-- 新增
        };
        ```
    *   导出 `initializeServices` 函数和/或导出一个在初始化后存储服务实例的对象。

2.  **修改 `main.js`**:
    *   在 `app.whenReady().then(async () => { ... })` 内部：
        *   **移除**旧的 `loadConfig()` 调用。
        *   **移除**旧的 `configManager.js` 相关调用 (`setConfig`, `getConfig`)。
        *   **移除**旧的 `imageCache.setConfig()` 调用。
        *   **调用服务初始化**:
            ```javascript
            const { initializeServices } = require('./src/services'); // 引入初始化函数
            const services = await initializeServices(); // 等待所有服务初始化完成
            log.info('[Main] 所有服务已初始化');

            // 使用 services.configService 获取配置来设置日志级别
            const appConfig = await services.configService.getConfig();
            let level = 'debug';
            if (appConfig && typeof appConfig.logLevel === 'string') {
              level = appConfig.logLevel;
            } // ... (保留原有的日志级别确定逻辑，但使用 appConfig)
            log.transports.file.level = level;
            log.transports.console.level = level;
            log.info(`[Log] 日志级别已根据服务配置设置为: ${level}`);

            // 使用 services.configService 获取配置来设置 imageCache
            imageCache.setConfig(appConfig.imageCache || {});
            log.info('[ImageCache] ImageCache 配置已根据服务设置');

            // 将 services 对象传递给需要它的地方，例如 IPC 初始化和窗口创建
            initializeIPC(services); // 修改或创建 IPC 初始化函数以接收 services
            createWindow(services); // 修改 createWindow 以接收 services, 并将 webContents 传递给 updateService
            ```
    *   **移除 `main.js` 中的 `getConfig` 和 `save-config` IPC Handlers**: 这两个 handler 将被移到专门的 IPC 文件中（见下一节）。
    *   **简化 `main.js` 中的 `updater.*` IPC Handlers**:
        *   `updater.checkForUpdate`: 移除内部逻辑，改为调用 `services.updateService.checkForUpdates();`。
        *   `updater.quitAndInstall`: 移除内部逻辑，改为调用 `services.updateService.quitAndInstall();`。

## 9. IPC 层重构
<!-- Section 9: IPC Layer Refactoring - Implementation Completed -->

**目标**: 移除业务逻辑，使 IPC 层成为调用服务层方法的轻量级路由。建议将应用相关的 IPC (如 Config, Update) 与模型库相关的 IPC 分开管理。

**方案**:
1.  保留 `src/ipc/modelLibraryIPC.js` 用于处理模型、数据源、图片相关的 IPC。
2.  **创建新文件 `src/ipc/appIPC.js`** 用于处理应用级别的 IPC，如配置、更新等。

**步骤**:

1.  **创建 `src/ipc/appIPC.js`**:
    *   引入 `ipcMain`, `log`, `BrowserWindow`。
    *   定义 `initializeAppIPC(services)` 函数，接收 `services` 对象。
    *   **迁移并重构 `getConfig` Handler**:
        ```javascript
        ipcMain.handle('getConfig', async () => {
          log.info('[IPC] getConfig 请求');
          try {
            return await services.configService.getConfig();
          } catch (error) {
            log.error('[IPC] 调用 configService.getConfig 失败:', error);
            throw error;
          }
        });
        ```
    *   **迁移并重构 `save-config` Handler**:
        ```javascript
        ipcMain.handle('save-config', async (event, newConfig) => {
          log.info('[IPC] save-config 请求');
          try {
            await services.configService.saveConfig(newConfig);
            // 保存成功后，执行原有的协调逻辑
            const updatedConfig = await services.configService.getConfig(); // 获取保存后的最新配置
            imageCache.setConfig(updatedConfig.imageCache || {});
            log.info('[IPC] ImageCache 配置已更新');
            BrowserWindow.getAllWindows().forEach(win => {
              if (win && win.webContents && !win.isDestroyed()) {
                win.webContents.send('config-updated');
              }
            });
            log.info('[IPC] config-updated 事件已发送至所有窗口');
            return { success: true };
          } catch (error) {
            log.error('[IPC] 调用 configService.saveConfig 或后续处理失败:', error);
            throw error;
          }
        });
        ```

2.  **修改 `src/ipc/modelLibraryIPC.js`**:
    *   修改 `initializeModelLibraryIPC` 函数，接收 `services` 对象。
    *   移除文件顶部的 `require('../configManager.js')`。
    *   移除对 `dataSourceInterface` 和 `modelParser` 的直接依赖（如果服务层已完全封装）。
    *   **重构各个 Handler (saveModel, listModels, listSubdirectories, getModelDetail, getModelImage)**:
        *   移除所有业务逻辑（文件读写、数据处理、缓存操作、数据源查找等）。
        *   简化为直接调用 `services.modelService` 或 `services.imageService` 的相应方法，并处理错误。
        *   示例 (`saveModel`):
            ```javascript
            ipcMain.handle('saveModel', async (event, model) => {
              log.info('[IPC] saveModel 请求', { jsonPath: model?.jsonPath });
              try {
                if (!model || !model.jsonPath) throw new Error('无效的模型数据或缺少 jsonPath');
                return await services.modelService.saveModel(model);
              } catch (error) {
                log.error('[IPC] 调用 modelService.saveModel 失败:', error.message, error.stack, { model });
                throw error;
              }
            });
            ```
        *   (其他 handler 类似地简化)

3.  **修改 `main.js`**:
    *   引入 `initializeAppIPC` 和 `initializeModelLibraryIPC`。
    *   在服务初始化后调用它们:
        ```javascript
        const { initializeAppIPC } = require('./src/ipc/appIPC');
        const { initializeModelLibraryIPC } = require('./src/ipc/modelLibraryIPC');
        // ... 服务初始化之后 ...
        initializeAppIPC(services);
        initializeModelLibraryIPC(services);
        log.info('[IPC] IPC Handlers 已初始化');
        ```

4.  **保留在 `main.js` 的 IPC Handlers**:
    *   以下 handlers 应**保留**在 `main.js` 中，因为它们与核心应用生命周期、窗口管理或基础 Electron API 调用紧密相关：
<!-- Section 10: main.js Cleanup - Implementation Completed -->
        *   `ipcMain.on('log-message', (event, level, ...args))`: 用于渲染进程日志记录，直接调用主进程 `log` 模块。属于基础架构。
        *   `ipcMain.on('renderer-error', (event, error))`: 用于渲染进程错误报告，直接调用主进程 `log` 模块。属于基础架构。
        *   `ipcMain.handle('open-folder-dialog', async () => ...)`: 直接调用 Electron 的 `dialog.showOpenDialog` API，与特定业务服务关联不大。
        *   `ipcMain.handle('updater.checkForUpdate', ...)`: **保留**，但内部逻辑简化为调用 `services.updateService.checkForUpdates()`。
        *   `ipcMain.handle('updater.quitAndInstall', ...)`: **保留**，但内部逻辑简化为调用 `services.updateService.quitAndInstall()`。

## 10. `main.js` 清理

**目标**: 移除 `main.js` 中已迁移到服务层或 IPC 文件的业务逻辑和不再需要的代码。

**需要移除/修改的内容**:

1.  **移除 `require`**:
    *   `require('./src/configManager.js')`
    *   `require('./src/data/dataSource')` (如果不再直接使用)
    *   `require('./src/data/webdavDataSource')` (如果不再直接使用)
    *   `require('./src/data/modelParser')`
    *   `require('./src/data/dataSourceInterface')`
2.  **移除函数**:
    *   `loadConfig()` 函数定义。
3.  **修改 `app.whenReady`**:
    *   移除 `loadConfig()` 调用。
    *   移除 `imageCache.setConfig()` 调用（移到服务初始化之后）。
    *   添加服务初始化调用 (`initializeServices`)。
    *   修改日志级别设置和 `imageCache` 设置，使其依赖于初始化后的 `services.configService`。
    *   添加 IPC 初始化调用 (`initializeAppIPC`, `initializeModelLibraryIPC`)。
4.  **移除 IPC Handlers**:
    *   **移除** `ipcMain.handle('getConfig', ...)` 的完整实现。
    *   **移除** `ipcMain.handle('save-config', ...)` 的完整实现。
5.  **简化 IPC Handlers**:
    *   简化 `ipcMain.handle('updater.checkForUpdate', ...)` 的内部逻辑。
    *   简化 `ipcMain.handle('updater.quitAndInstall', ...)` 的内部逻辑。
6.  **移除 `window-all-closed` 中的缓存清理**:
    *   `imageCache.clearCache()`: 这个逻辑可以考虑移到 `ImageService` 的关闭/清理方法中（如果需要），或者暂时保留在 `main.js`，但通过 `services.imageService` 调用（如果 `ImageService` 提供了接口）。
    *   WebDAV 缓存清理: 这个逻辑与 `dataSourceInterface` 或潜在的 `DataSourceService` 相关，也应考虑迁移。

## 11. 缺失功能识别

根据设计方案和服务接口定义，目前分析的代码**似乎覆盖了**设计方案中提到的主要服务接口的核心功能。在迁移过程中需要注意：

*   **错误处理一致性**: 确保服务层方法和重构后的 IPC Handler 在错误处理（日志记录、是否向渲染进程抛出错误）方面保持一致或符合预期。
*   **参数校验**: 决定参数校验（例如 `sourceId` 是否存在、路径是否有效）应该在 IPC 层进行还是在服务层内部进行，并确保实施。
*   **UpdateService 与窗口通信**: 需要确保 `UpdateService` 能够有效地将状态发送给渲染进程窗口。这通常需要在创建窗口后，将 `webContents` 对象传递给 `UpdateService` 实例。

## 12. 后续步骤

1.  **代码实现**: 按照本文档的步骤，逐步修改代码，创建服务文件，迁移逻辑。
2.  **单元测试**: 为每个服务编写单元测试，模拟依赖项，验证其核心逻辑。
3.  **集成测试**: 测试 IPC 调用是否能正确路由到服务层并返回预期结果。
4.  **端到端测试**: 运行应用程序，手动测试所有相关功能（加载模型、查看详情、保存模型、更改配置、图片显示、检查更新等），确保功能正常。
5.  **代码审查**: 对重构后的代码进行审查，确保符合设计目标和编码规范。